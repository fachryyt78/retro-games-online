<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Retro Games Online — Frogget</title>
  <link rel="preconnect" href="https://fonts.googleapis.com" />
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin />
  <link href="https://fonts.googleapis.com/css2?family=Press+Start+2P&display=swap" rel="stylesheet" />
  <style>
    :root {
      --bg: #0f1419;
      --road: #1a1a1a;
      --grass: #2d5016;
      --frog: #7cb342;
      --car1: #c62828;
      --car2: #1565c0;
      --car3: #f9a825;
      --white: #e8e8e8;
      --pixel: 24px;
      --font: 'Press Start 2P', cursive;
    }

    * { box-sizing: border-box; margin: 0; padding: 0; }

    body {
      font-family: var(--font);
      background: var(--bg);
      color: var(--white);
      min-height: 100vh;
      display: flex;
      flex-direction: column;
      align-items: center;
      padding: 16px;
      font-size: 10px;
      background-image: radial-gradient(ellipse at 50% 0%, #1a2332 0%, var(--bg) 60%);
    }

    h1 {
      font-size: 14px;
      margin-bottom: 8px;
      color: var(--frog);
      text-shadow: 2px 2px 0 #1a1a1a;
      letter-spacing: 2px;
    }

    .subtitle {
      font-size: 8px;
      color: #6b7280;
      margin-bottom: 16px;
    }

    .game-wrap {
      border: 4px solid var(--white);
      padding: 8px;
      background: var(--grass);
      image-rendering: pixelated;
      image-rendering: crisp-edges;
      box-shadow: inset 0 0 0 2px #1a1a1a, 0 8px 24px rgba(0,0,0,0.5);
    }

    #game {
      display: block;
      background: var(--road);
    }

    .hud {
      display: flex;
      justify-content: space-between;
      width: 100%;
      max-width: 352px;
      margin-top: 12px;
      font-size: 8px;
    }

    .hud span { margin-right: 12px; }

    .controls {
      margin-top: 16px;
      font-size: 8px;
      color: #9ca3af;
      text-align: center;
      line-height: 2;
    }

    .controls kbd {
      background: #374151;
      padding: 2px 6px;
      border-radius: 4px;
      font-family: var(--font);
      margin: 0 2px;
    }

    .screen {
      position: absolute;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: center;
      background: rgba(15, 20, 25, 0.95);
      font-size: 10px;
      text-align: center;
      padding: 24px;
    }

    .screen.hidden { display: none; }

    .screen h2 { margin-bottom: 12px; font-size: 12px; color: var(--frog); }
    .screen p { margin-bottom: 8px; color: #9ca3af; line-height: 1.8; }
    .screen .score-line { font-size: 14px; color: var(--white); margin: 12px 0; }

    button {
      font-family: var(--font);
      font-size: 10px;
      padding: 12px 24px;
      margin-top: 12px;
      background: var(--frog);
      color: var(--bg);
      border: none;
      cursor: pointer;
      image-rendering: pixelated;
    }
    button:hover { filter: brightness(1.2); }
    button:active { transform: scale(0.98); }

    .canvas-wrap {
      position: relative;
      width: fit-content;
      height: fit-content;
    }

    .scanline {
      position: absolute;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      pointer-events: none;
      background: repeating-linear-gradient(
        0deg,
        transparent,
        transparent 2px,
        rgba(0,0,0,0.06) 2px,
        rgba(0,0,0,0.06) 4px
      );
    }

    .high-scores {
      max-width: 352px;
      width: 100%;
      margin-top: 24px;
      padding: 12px;
      background: rgba(26, 26, 26, 0.8);
      border: 2px solid #374151;
      font-size: 8px;
    }

    .high-scores h3 {
      font-size: 8px;
      margin-bottom: 8px;
      color: var(--frog);
    }

    .high-scores ol {
      list-style: none;
      padding-left: 0;
    }

    .high-scores li {
      display: flex;
      justify-content: space-between;
      padding: 4px 0;
      border-bottom: 1px solid #374151;
      color: #9ca3af;
    }

    .high-scores li span.score { color: var(--white); }

    .about {
      max-width: 352px;
      margin-top: 24px;
      padding: 12px;
      font-size: 7px;
      color: #6b7280;
      line-height: 2;
      text-align: center;
    }

    .about a { color: var(--frog); }

    .about h3 { font-size: 8px; color: var(--frog); margin-bottom: 8px; }

    .settings-panel {
      max-width: 352px;
      width: 100%;
      margin-top: 16px;
      padding: 12px;
      background: rgba(26, 26, 26, 0.6);
      border: 2px solid #374151;
      font-size: 7px;
    }

    .settings-panel label { display: flex; align-items: center; gap: 8px; margin-bottom: 8px; cursor: pointer; color: #9ca3af; }
    .settings-panel input[type="checkbox"] { width: 14px; height: 14px; accent-color: var(--frog); }
    .settings-panel select { font-family: var(--font); font-size: 7px; background: #374151; color: var(--white); border: none; padding: 4px 8px; }

    .touch-buttons {
      display: none;
      grid-template-columns: repeat(3, 64px);
      grid-template-rows: repeat(3, 64px);
      gap: 4px;
      margin-top: 12px;
      place-items: center;
    }

    .touch-buttons.visible { display: grid; }

    .touch-buttons button {
      width: 56px;
      height: 56px;
      padding: 0;
      font-size: 18px;
      background: #374151;
      color: var(--white);
    }

    .touch-buttons button:active { background: var(--frog); color: var(--bg); }

    .touch-buttons .up { grid-column: 2; grid-row: 1; }
    .touch-buttons .down { grid-column: 2; grid-row: 3; }
    .touch-buttons .left { grid-column: 1; grid-row: 2; }
    .touch-buttons .right { grid-column: 3; grid-row: 2; }

    @media (max-width: 420px) {
      .game-wrap { padding: 4px; }
      #game { width: 100%; height: auto; max-width: 352px; }
      .touch-buttons.visible { display: grid; }
    }

    button:focus-visible,
    .touch-buttons button:focus-visible {
      outline: 2px solid var(--frog);
      outline-offset: 2px;
    }

    @keyframes blink {
      0%, 50% { opacity: 1; }
      51%, 100% { opacity: 0.6; }
    }

    .screen h2 {
      animation: blink 1s ease-in-out infinite;
    }

    #game:focus { outline: none; }
  </style>
</head>
<body>
  <h1>RETRO GAMES ONLINE</h1>
  <p class="subtitle">FROGGET — CROSS THE ROAD</p>

  <div class="game-wrap">
    <div class="canvas-wrap">
      <canvas id="game" width="352" height="384"></canvas>
      <div class="scanline" aria-hidden="true"></div>
      <div id="screen-start" class="screen">
        <h2>FROGGET</h2>
        <p>Get the frog to the top safe zone.<br>Avoid the cars. One hop per move.</p>
        <p>Use arrow keys or WASD.</p>
        <button type="button" id="btn-start">START</button>
      </div>
      <div id="screen-level" class="screen hidden">
        <h2>LEVEL CLEAR</h2>
        <p class="score-line">SCORE: <span id="level-score">0</span></p>
        <button type="button" id="btn-next-level">NEXT LEVEL</button>
      </div>
      <div id="screen-gameover" class="screen hidden">
        <h2>GAME OVER</h2>
        <p class="score-line">SCORE: <span id="go-score">0</span> &nbsp; LEVEL: <span id="go-level">1</span></p>
        <button type="button" id="btn-restart">PLAY AGAIN</button>
      </div>
      <div id="screen-pause" class="screen hidden">
        <h2>PAUSED</h2>
        <p>Press P or click to resume.</p>
        <button type="button" id="btn-resume">RESUME</button>
      </div>
    </div>
  </div>

  <div class="hud">
    <span>SCORE: <strong id="hud-score">0</strong></span>
    <span>LEVEL: <strong id="hud-level">1</strong></span>
    <span>LIVES: <strong id="hud-lives">3</strong></span>
  </div>

  <div class="touch-buttons" id="touch-buttons">
    <button type="button" class="up" aria-label="Up">&#8593;</button>
    <button type="button" class="left" aria-label="Left">&#8592;</button>
    <button type="button" class="right" aria-label="Right">&#8594;</button>
    <button type="button" class="down" aria-label="Down">&#8595;</button>
  </div>

  <p class="controls">
    <kbd>↑</kbd><kbd>↓</kbd><kbd>←</kbd><kbd>→</kbd> or <kbd>W</kbd><kbd>A</kbd><kbd>S</kbd><kbd>D</kbd> &nbsp; Pause: <kbd>P</kbd>
  </p>

  <section class="about" id="shortcuts">
    <h3>KEYBOARD</h3>
    <p>Up / W — hop up. Down / S — hop down. Left / A — hop left. Right / D — hop right. P — pause and resume. All other keys are ignored during play.</p>
  </section>

  <section class="about">
    <p>Retro Games Online — Frogget. Single-page web game. No account required. High scores stored locally. Change speed in Settings to make the game easier (Slow) or harder (Fast).</p>
  </section>

  <section class="about">
    <p>© Retro Games Online. Frogget contract: single Java file, no readonly; immutable config; constructor-set; unique contract id and hex constants.</p>
  </section>

  <section class="about">
    <p>Play again: click START or RESTART. Pause with P. Adjust speed in Settings for a different challenge.</p>
  </section>

  <section class="about">
    <p>Compatible with desktop and mobile. Touch devices show on-screen direction buttons. Enjoy the game!</p>
    <p>Frogget — Ribbit-cross lane ledger. Retro style. Have fun!</p>
    <!-- Retro Games Online — Frogget web interface -->
  </section>

  <section class="high-scores">
    <h3>HIGH SCORES</h3>
    <ol id="high-score-list"></ol>
  </section>

  <section class="settings-panel">
    <h3>SETTINGS</h3>
    <label><input type="checkbox" id="opt-sound" checked /> Sound effects (placeholder)</label>
    <label>Speed: <select id="opt-speed"><option value="12">Normal</option><option value="10">Slow</option><option value="14">Fast</option></select></label>
  </section>

  <section class="about" id="how-to-play">
    <h3 style="font-size:8px;color:var(--frog);margin-bottom:8px;">HOW TO PLAY</h3>
    <p>Guide the frog from the bottom safe zone (green) to the top. Each lane has cars moving left or right. One hop per key press. Reach the top to clear the level and earn points. Get hit and you lose a life; no lives left is game over. Higher levels add more and faster traffic. Good luck!</p>
  </section>

  <section class="about" id="tips">
    <h3>TIPS</h3>
    <p>Wait for a gap before crossing. Time your hops so you land between cars. The top and bottom rows are safe — catch your breath there. Use the pause key (P) if you need a break. High scores are saved in this browser.</p>
  </section>

  <section class="about" id="levels">
    <h3>LEVELS</h3>
    <p>Level 1–2: Few cars, slow. Level 3–4: More cars. Level 5+: Denser traffic. Speed and spawn rate increase with level. No upper level cap in this web version.</p>
  </section>

  <section class="about" id="credits">
    <h3>CREDITS</h3>
    <p>Frogget game logic and constants are defined in a single Java file (Frogget.java). This web interface reproduces the same rules: 11 columns, 9 rows, 7 traffic lanes, 3 lives, 4 ticks per vehicle move. Safe zones at row 0 and row 8. Score 100 + level×10 per crossing; 50 bonus per level clear. No token, no claim. Part of Retro Games Online.</p>
    <p>Font: Press Start 2P (Google Fonts). Colors: green grass #2d5016, frog #7cb342, cars red/blue/yellow. Canvas 352×384 px, cell 32×32. FPS selectable (10/12/14) in Settings.</p>
  </section>

  <footer class="about">
    Frogget — retro frog crossing. No token, no claim. Contract logic: single file, constructor-set config. Part of Retro Games Online.
  </footer>

  <script>
    (function () {
      // -----------------------------------------------------------------------
      // Frogget — retro frog crossing. Constants match contract defaults where
      // applicable (COLS 11, ROWS 9, LANES 7, 3 lives, etc.)
      // -----------------------------------------------------------------------
      // loadHighScores / saveHighScores: localStorage key frogget_high_scores
      // buildLanes(level): one lane per row 1..LANES, alternating direction
      // initLevel: reset frog to bottom center, rebuild lanes for current level
      // resetGame: full reset for new game
      // moveFrog(dRow,dCol): clamp to grid, detect safe top row for level clear
      // checkCollision: true if frog cell overlaps any obstacle in current lane
      // updateLanes: move obstacles by direction, remove off-screen, spawn new
      // tick: advance time, run updateLanes every TICKS_PER_MOVE, then collision
      // draw: clear canvas, draw safe zones (green), road (grey), cars, frog
      // loop: requestAnimationFrame, elapsed ticks from getFPS(), then draw
      // Key handlers: Arrow/WASD move, P toggles pause
      // Buttons: START (hide start screen), NEXT LEVEL (level++, initLevel), RESTART, RESUME
      // Touch: optional D-pad for mobile when ontouchstart is present
      // -----------------------------------------------------------------------
      // Grid: rows 0 (safe top), 1..7 (lanes), 8 (safe bottom). Cols 0..10.
      // Frog start: row 8, col 5. Goal: row 0.
      // Obstacles: col + length; move by +1 or -1 per tick block.
      // Spawn: probability 0.15 every 8 ticks; length 2 or 3; sprite 0/1/2 for color.
      // CAR_COLORS: red, blue, yellow. Frog: green with dark border and eye highlight.
      // High scores: sorted by score desc, max 10; stored as { score, level, ts }.
      // Pause: state.paused; no tick(), draw() still runs; P or Resume button.
      // -----------------------------------------------------------------------
      const COLS = 11;
      const ROWS = 9;
      const CELL_W = 32;
      const CELL_H = 32;
      const LANES = 7;
      const SAFE_TOP = 0;
      const SAFE_BOTTOM = 8;
      const FROG_START_ROW = 8;
      const TICKS_PER_MOVE = 4;
      const DIR_LEFT = -1;
      const DIR_RIGHT = 1;
      const HIGH_SCORE_KEY = 'frogget_high_scores';
      const MAX_HIGH_SCORES = 10;
      const DEFAULT_FPS = 12;

      // Points: 100 base + level*10 per safe cross; 50 bonus on level advance (matches Frogget.java)
      const POINTS_BASE_CROSS = 100;
      const POINTS_LEVEL_BONUS = 50;

      function getFPS() {
        const el = document.getElementById('opt-speed');
        return el ? parseInt(el.value, 10) || DEFAULT_FPS : DEFAULT_FPS;
      }

      const canvas = document.getElementById('game');
      const ctx = canvas.getContext('2d');

      let state = {
        frogRow: FROG_START_ROW,
        frogCol: Math.floor(COLS / 2),
        lives: 3,
        score: 0,
        level: 1,
        tick: 0,
        gameOver: false,
        levelComplete: false,
        paused: false,
        lanes: [],
        frogFrame: 0
      };

      function loadHighScores() {
        try {
          const raw = localStorage.getItem(HIGH_SCORE_KEY);
          if (raw) return JSON.parse(raw);
        } catch (e) {}
        return [];
      }

      function saveHighScores(list) {
        try {
          localStorage.setItem(HIGH_SCORE_KEY, JSON.stringify(list.slice(0, MAX_HIGH_SCORES)));
        } catch (e) {}
      }

      function addHighScore(score, level) {
        const list = loadHighScores();
        list.push({ score: score, level: level, ts: Date.now() });
        list.sort((a, b) => b.score - a.score);
        saveHighScores(list);
        renderHighScores();
      }

      function renderHighScores() {
        const list = loadHighScores();
        const ol = document.getElementById('high-score-list');
        ol.innerHTML = '';
        list.slice(0, MAX_HIGH_SCORES).forEach((entry, i) => {
          const li = document.createElement('li');
          li.innerHTML = '<span>' + (i + 1) + '. Lv.' + entry.level + '</span><span class="score">' + entry.score + '</span>';
          ol.appendChild(li);
        });
        if (list.length === 0) {
          const li = document.createElement('li');
          li.textContent = 'No scores yet';
          li.style.color = '#6b7280';
          ol.appendChild(li);
        }
      }

      function buildLanes(level) {
        const lanes = [];
        for (let r = 1; r <= LANES; r++) {
          const dir = (r + level) % 2 === 0 ? DIR_RIGHT : DIR_LEFT;
          const obstacles = [];
          const len = 2 + Math.min(level, 3);
          for (let i = 0; i < len; i++) {
            const length = 2 + (i % 2);
            const col = dir === DIR_RIGHT ? -length - i * 4 : COLS + i * 4;
            const sprite = (r + i) % 3;
            obstacles.push({ col: col, length: length, sprite: sprite });
          }
          lanes.push({ row: r, direction: dir, obstacles: obstacles });
        }
        return lanes;
      }

      function initLevel() {
        state.frogRow = FROG_START_ROW;
        state.frogCol = Math.floor(COLS / 2);
        state.levelComplete = false;
        state.lanes = buildLanes(state.level);
      }

      function resetGame() {
        state.frogRow = FROG_START_ROW;
        state.frogCol = Math.floor(COLS / 2);
        state.lives = 3;
        state.score = 0;
        state.level = 1;
        state.tick = 0;
        state.gameOver = false;
        state.levelComplete = false;
        state.paused = false;
        state.lanes = buildLanes(state.level);
      }

      function moveFrog(dRow, dCol) {
        if (state.gameOver || state.levelComplete || state.paused) return;
        const nr = state.frogRow + dRow;
        const nc = state.frogCol + dCol;
        if (nr < 0 || nr > ROWS || nc < 0 || nc >= COLS) return;
        state.frogRow = nr;
        state.frogCol = nc;
        state.frogFrame = 1;
        if (nr === SAFE_TOP) {
          state.score += POINTS_BASE_CROSS + state.level * 10;
          state.levelComplete = true;
          document.getElementById('level-score').textContent = state.score;
          document.getElementById('screen-level').classList.remove('hidden');
          document.getElementById('screen-gameover').classList.add('hidden');
          document.getElementById('screen-start').classList.add('hidden');
          document.getElementById('screen-pause').classList.add('hidden');
        }
      }

      function checkCollision() {
        if (state.frogRow <= SAFE_BOTTOM) return false;
        const li = state.frogRow - SAFE_BOTTOM - 1;
        if (li < 0 || li >= state.lanes.length) return false;
        const lane = state.lanes[li];
        for (const ob of lane.obstacles) {
          if (state.frogCol >= ob.col && state.frogCol < ob.col + ob.length) return true;
        }
        return false;
      }

      function updateLanes() {
        for (const lane of state.lanes) {
          const dir = lane.direction;
          for (const ob of lane.obstacles) ob.col += dir;
          lane.obstacles = lane.obstacles.filter(ob => ob.col + ob.length >= 0 && ob.col < COLS);
          if (state.tick % 8 === 0 && Math.random() < 0.15) {
            const length = 2 + Math.floor(Math.random() * 2);
            const startCol = dir === DIR_RIGHT ? -length : COLS;
            const sprite = Math.floor(Math.random() * 3);
            lane.obstacles.push({ col: startCol, length: length, sprite: sprite });
          }
        }
      }

      function tick() {
        if (state.gameOver || state.levelComplete || state.paused) return;
        state.tick++;
        if (state.frogFrame > 0) state.frogFrame = 0;
        if (state.tick % TICKS_PER_MOVE !== 0) return;
        updateLanes();
        if (checkCollision()) {
          state.lives--;
          if (state.lives <= 0) {
            state.gameOver = true;
            addHighScore(state.score, state.level);
            document.getElementById('go-score').textContent = state.score;
            document.getElementById('go-level').textContent = state.level;
            document.getElementById('screen-gameover').classList.remove('hidden');
            document.getElementById('screen-level').classList.add('hidden');
            document.getElementById('screen-start').classList.add('hidden');
            document.getElementById('screen-pause').classList.add('hidden');
          } else {
            state.frogRow = FROG_START_ROW;
            state.frogCol = Math.floor(COLS / 2);
          }
        }
      }

      const CAR_COLORS = ['#c62828', '#1565c0', '#f9a825'];

      function draw() {
        ctx.fillStyle = '#1a1a1a';
        ctx.fillRect(0, 0, canvas.width, canvas.height);

        for (let r = 0; r <= ROWS; r++) {
          const y = r * CELL_H;
          if (r === SAFE_TOP || r === SAFE_BOTTOM) {
            ctx.fillStyle = '#2d5016';
            ctx.fillRect(0, y, canvas.width, CELL_H);
            ctx.fillStyle = '#1a1a1a';
            for (let c = 0; c < COLS; c++) {
              ctx.fillRect(c * CELL_W + 2, y + 2, CELL_W - 4, CELL_H - 4);
            }
            ctx.fillStyle = '#374151';
            ctx.fillRect(0, y + CELL_H - 4, canvas.width, 2);
          } else {
            ctx.fillStyle = '#252525';
            ctx.fillRect(0, y, canvas.width, CELL_H);
            ctx.fillStyle = '#333';
            for (let c = 0; c < COLS; c++) {
              ctx.fillRect(c * CELL_W, y + CELL_H / 2 - 1, CELL_W, 2);
            }
            const li = r - SAFE_BOTTOM - 1;
            if (li >= 0 && li < state.lanes.length) {
              const lane = state.lanes[li];
              for (const ob of lane.obstacles) {
                ctx.fillStyle = CAR_COLORS[ob.sprite % CAR_COLORS.length];
                for (let i = 0; i < ob.length; i++) {
                  const x = (ob.col + i) * CELL_W;
                  if (x >= -CELL_W && x < canvas.width) {
                    ctx.fillRect(x + 2, y + 2, CELL_W - 4, CELL_H - 4);
                    ctx.fillStyle = 'rgba(255,255,255,0.3)';
                    ctx.fillRect(x + 4, y + 4, 6, 6);
                    ctx.fillStyle = CAR_COLORS[ob.sprite % CAR_COLORS.length];
                  }
                }
              }
            }
          }
        }

        const fx = state.frogCol * CELL_W;
        const fy = state.frogRow * CELL_H;
        const pad = state.frogFrame === 1 ? 2 : 4;
        ctx.fillStyle = '#7cb342';
        ctx.fillRect(fx + pad, fy + pad, CELL_W - pad * 2, CELL_H - pad * 2);
        ctx.strokeStyle = '#2d5016';
        ctx.lineWidth = 2;
        ctx.strokeRect(fx + pad, fy + pad, CELL_W - pad * 2, CELL_H - pad * 2);
        ctx.fillStyle = 'rgba(255,255,255,0.4)';
        ctx.fillRect(fx + pad + 4, fy + pad + 2, 4, 4);

        document.getElementById('hud-score').textContent = state.score;
        document.getElementById('hud-level').textContent = state.level;
        document.getElementById('hud-lives').textContent = state.lives;
      }

      let lastTick = 0;
      function loop(now) {
        const fps = getFPS();
        const msPerTick = 1000 / fps;
        if (!state.gameOver && !state.levelComplete && !state.paused) {
          const elapsed = Math.min(5, Math.floor((now - lastTick) / msPerTick));
          for (let i = 0; i < elapsed; i++) tick();
          lastTick = now;
        } else if (state.paused) {
          lastTick = now;
        }
        draw();
        requestAnimationFrame(loop);
      }
      requestAnimationFrame(function (now) { lastTick = now; requestAnimationFrame(loop); });

      document.addEventListener('keydown', function (e) {
        if (e.code === 'KeyP') {
          e.preventDefault();
          if (state.gameOver || state.levelComplete) return;
          state.paused = !state.paused;
          const el = document.getElementById('screen-pause');
          if (state.paused) el.classList.remove('hidden');
          else el.classList.add('hidden');
          return;
        }
        if (['ArrowUp','ArrowDown','ArrowLeft','ArrowRight','KeyW','KeyA','KeyS','KeyD'].indexOf(e.code) >= 0) e.preventDefault();
        switch (e.code) {
          case 'ArrowUp': case 'KeyW': moveFrog(-1, 0); break;
          case 'ArrowDown': case 'KeyS': moveFrog(1, 0); break;
          case 'ArrowLeft': case 'KeyA': moveFrog(0, -1); break;
          case 'ArrowRight': case 'KeyD': moveFrog(0, 1); break;
          default: break;
        }
      });

      document.getElementById('btn-start').addEventListener('click', function () {
        resetGame();
        document.getElementById('screen-start').classList.add('hidden');
        document.getElementById('screen-level').classList.add('hidden');
        document.getElementById('screen-gameover').classList.add('hidden');
        document.getElementById('screen-pause').classList.add('hidden');
      });

      document.getElementById('btn-next-level').addEventListener('click', function () {
        state.level++;
        state.score += 50;
        initLevel();
        document.getElementById('screen-level').classList.add('hidden');
      });

      document.getElementById('btn-restart').addEventListener('click', function () {
        resetGame();
        document.getElementById('screen-gameover').classList.add('hidden');
        document.getElementById('screen-level').classList.add('hidden');
        document.getElementById('screen-start').classList.add('hidden');
        document.getElementById('screen-pause').classList.add('hidden');
      });

      document.getElementById('btn-resume').addEventListener('click', function () {
        state.paused = false;
        document.getElementById('screen-pause').classList.add('hidden');
      });

      document.getElementById('screen-pause').addEventListener('click', function (e) {
        if (e.target === e.currentTarget || e.target.id === 'btn-resume') {
          state.paused = false;
          document.getElementById('screen-pause').classList.add('hidden');
        }
      });

      const touchBtns = document.getElementById('touch-buttons');
      if ('ontouchstart' in window) touchBtns.classList.add('visible');
      touchBtns.querySelector('.up').addEventListener('click', () => moveFrog(-1, 0));
      touchBtns.querySelector('.down').addEventListener('click', () => moveFrog(1, 0));
      touchBtns.querySelector('.left').addEventListener('click', () => moveFrog(0, -1));
      touchBtns.querySelector('.right').addEventListener('click', () => moveFrog(0, 1));

      renderHighScores();

      // -----------------------------------------------------------------------
      // Helpers and compatibility
      // -----------------------------------------------------------------------
      function isTouchDevice() {
        return 'ontouchstart' in window || navigator.maxTouchPoints > 0;
      }

      function persistState() {
        try {
          const data = {
            score: state.score,
            level: state.level,
            lives: state.lives,
            ts: Date.now()
          };
          sessionStorage.setItem('frogget_session', JSON.stringify(data));
        } catch (e) {}
      }

      function hasStoredSession() {
        try {
          const raw = sessionStorage.getItem('frogget_session');
          if (!raw) return false;
          const data = JSON.parse(raw);
          return data && typeof data.score === 'number' && Date.now() - (data.ts || 0) < 3600000;
        } catch (e) { return false; }
      }

      window.froggetGetState = function () {
        return {
          score: state.score,
          level: state.level,
          lives: state.lives,
          gameOver: state.gameOver,
          levelComplete: state.levelComplete
        };
      };

      window.froggetReset = resetGame;

      document.getElementById('opt-speed').addEventListener('change', function () {
        lastTick = performance.now();
      });

      document.getElementById('opt-sound').addEventListener('change', function () {
        // Placeholder: could wire to Web Audio or mute flag for future SFX
      });

      // Optional: expose FPS and constants for debugging
      window.froggetFPS = getFPS;
      window.froggetConstants = {
        COLS: COLS,
        ROWS: ROWS,
        LANES: LANES,
        POINTS_BASE_CROSS: POINTS_BASE_CROSS,
        POINTS_LEVEL_BONUS: POINTS_LEVEL_BONUS
      };

      var LEVEL_DESCRIPTIONS = [
        'Level 1: Start slow. Two cars per lane.',
        'Level 2: Same pace, get used to the rhythm.',
        'Level 3: More cars. Watch both directions.',
        'Level 4: Denser traffic. Plan your path.',
        'Level 5: Harder. Time your hops carefully.',
        'Level 6: Even more vehicles. No room for error.',
        'Level 7: Expert. Quick decisions needed.',
        'Level 8: Very hard. Patience and timing.',
        'Level 9: Near maximum density.',
        'Level 10+: Maximum challenge.'
      ];

      window.froggetLevelDescription = function (level) {
        var idx = Math.min(level - 1, LEVEL_DESCRIPTIONS.length - 1);
        return LEVEL_DESCRIPTIONS[idx >= 0 ? idx : 0] || 'Level ' + level;
      };
    })();
  </script>
</body>
</html>

